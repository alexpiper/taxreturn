
# PHMM------------------------------------------------------------
#' Map to model
#'
#' @description This function alignes sequences to a Profile Hidden Markov Model (PHMM) using the Viterbi algorithm in order to retain only the target loci.
#' This function can also be used to extract smaller subregions out of longer sequences, for instance extracting the COI barcode region from mitochondrial genomes.
#' In order to reduce the number of sequences for alignment using the computationally expensive Viterbi algorithm, a rapid kmer distance screen is first conducted to remove any sequence too far diverged from the reference PHMM.
#' Similarly, all sequences that are more than twice the length of the reference PHMM model are broken into chunks of the same length as the model, and a rapid kmer screen conducted. The sequence is then subset to the most similar chunk and its two adjacent chunks prior to Viterbi alignment.
#'
#' @param x A DNAbin or DNAStringset object
#' @param model A Profile Hidden Markov model ("PHMM" object) generated by `aphid::derivePHMM` to align the sequences to.
#' An already derived model of COI can be loaded using `data("model", package="taxreturn")`
#' @param min_score The minimum specificity (log-odds score for the optimal alignment) between the query sequence and the PHMM model for the sequence to be retained.
#' see `?aphid::Viterbi` for more information about the alignment process.
#' @param min_length The minimum length of the match between the query and PHMM for a sequence to retained. Takes into account sequential matches, as well as any internal insertions or deletions below max_indel.
#' @param max_indel The maximum number of internal insertions or deletions within the sequence to allow.
#' @param max_gap The maximum number of gaps within the sequence to allow.
#' @param max_N The max number of ambiguous N bases allowed before a sequence is removed.
#' @param check_frame Whether sequences with insertions or deletions which arent in multiples of 3 should be removed from output. Useful for coding loci such as COI but should not be used for non-coding loci. Default is FALSE.
#' @param kmer_threshold the maximum kmer distance allowed from the reference model. If a sequence is further than this, it will be skipped from the slower Viterbi alignment. Default is 50% (0.5)
#' @param k integer giving the k-mer size used to generate the input matrix for k-means clustering. Default is k=5.
#' @param shave Whether bases that are outside (to the left or right) of the PHMM object should be removed from sequences in the output. Default is TRUE.
#' @param trim_ends Sometimes a trailing base can end up at the end of the alignment, separated by gaps. the trim_ends parameter checks up to n bases from each end of the alignment and if gaps are detected, any trailing bases will be removed.
#' @param extra How to handle insertions which were not part of the PHMM model. 'drop' will truncate all sequences to the shortest alignment length, while 'fill' will use gaps to pad all sequences out to the longest alignment length.
#' @param multithread Whether multithreading should be used, if TRUE the number of cores will be automatically detected (Maximum available cores - 1), or provide a numeric vector to manually set the number of cores to use. Default is FALSE (single thread)
#' @param quiet Whether progress should be printed to the console. Note that this will add additional runtime.
#' @param progress Whether a progress bar is displayed.
#'
#' @import stringr
#' @import furrr
#' @import future
#' @import dplyr
#' @importFrom ape as.DNAbin
#' @importFrom ape base.freq
#' @importFrom methods is
#'
#' @return
#' @export
#'
map_to_model <- function(x, model, min_score = 100, min_length = 1, max_indel = 9, max_gap = Inf, max_N = Inf,
                          check_frame = FALSE, kmer_threshold=0.5, k=5, shave = TRUE, trim_ends=FALSE, extra=NA,
                          multithread = FALSE, quiet = FALSE, progress = FALSE) {
  time <- Sys.time() # get time

  # Check inputs
  if (!methods::is(model, "PHMM")) {
    stop("Model needs to be a PHMM object")
  }
  if(!is.na(extra)){
    if(!extra %in% c("fill", "drop")) stop("extra must be 'fill', 'drop', or NA")
  }
  # Convert to DNAbin
  if (!methods::is(x, "DNAbin")) {
    x <- ape::as.DNAbin(x)
    if (all(is.na(ape::base.freq(x)))) {stop("Error: Object is not coercible to DNAbin \n")}
  }
  if(!is.numeric(kmer_threshold) | !dplyr::between(kmer_threshold, 0,1)) { stop("Threshold must be a numeric between 0 and 1")}

  # Set up multithreading
  setup_multithread(multithread = multithread, quiet=quiet)

  # Ensure all sequences are above the kmer size
  no_gaps<- lapply(x, function(s) s[!(s %in% as.raw(c(2, 4, 240)))])
  x <- x[sapply(no_gaps, length) > k + 1]

  # Process long sequences & short sequences separately
  long_seqs <- x[lengths(x) > (model$size * 2)]
  short_seqs <- x[lengths(x) <= (model$size * 2)]

  # Conduct a quick kmer screen directly on the short sequences
  if(length(short_seqs) > 0){
    short_seqs <- kmer_screen(short_seqs, model, threshold=kmer_threshold, k = k, quiet= TRUE)
  }

  # Split the long sequences into chunks and conduct kmer screen on each chunk
  if(length(long_seqs) > 0){
    long_seqs <- long_seqs %>%
      furrr::future_map(subset_long_seq, model = model, split_length = model$size, threshold = kmer_threshold, k = k,
                        .progress = progress, .options = furrr::furrr_options(seed = TRUE))
    class(long_seqs) <- "DNAbin"
  }

  # Join short and long seqs together again
  x[names(long_seqs)] <- long_seqs
  x <- x[!names(x) %in% names(x)[!names(x) %in% c(names(short_seqs), names(long_seqs))]]

  #Apply filt_phmm to all sequences
  res <- furrr::future_map(x, filt_phmm, model=model, min_score=min_score, min_length=min_length, max_indel = max_indel,
                           shave=shave, trim_ends = trim_ends, check_frame=check_frame,
                           .progress = progress, .options = furrr::furrr_options(seed = TRUE))

  #Close all worker threads
  future::plan(future::sequential)

  # Filter sequences that didnt pass min_score or min_length
  discards <- sapply(res, is.null)

  if (sum(!discards) > 0) {
    if (!quiet) message("Retained ", sum(!discards), " sequences after alignment to PHMM \n")
    res <- res[!discards]
  } else {
    warning("None of the sequences met PHMM specificity criteria. Returning NULL \n")
    return(NULL)
  }

  # Remove sequences above max_N
  if(max_N < Inf){
    discards <- sapply(res, function(s) sum(s == as.raw(240))) > max_N
    res <- res[!discards]
    if (!quiet) message("Retained ", length(res), " sequences after applying ambiguity filter \n")
  }

  # Remove sequences above max_gap
  if(max_gap < Inf){
    discards <- sapply(res, function(s) sum(s == as.raw(c(4))))  > max_gap
    res <- res[!discards]
    if (!quiet) message("Retained ", length(res), " sequences after applying gap filter \n")
  }

  # Ensure outputs are consistent length
  size_range <- range(sapply(res, length))
  if(!(size_range[1]==size_range[2])){
    if(!is.na(extra) & extra=="fill"){
      res <- lapply(res, function(y) {
        z <- y[1:size_range[2]]
        z[z==00] <- as.raw(04)
        return(z)
      })
      message("Output sequences were of mixed lengths between ", size_range[1], "bp and ", size_range[2], "bp extra was filled")
    } else if(!is.na(extra) & extra=="drop"){
      res <- lapply(res, function(y) {y[1:size_range[1]]})
      message("Output sequences were of mixed lengths between ", size_range[1], "bp and ", size_range[2], "bp extra was dropped")
    } else if(is.na(extra)){
      warning("Output sequences are not all the same length due to insertion positions not present in the model, set extra='drop'truncate all sequences to the shortest alignment or extra='fill' to fill with gaps")
    }
  }
  class(res) <- "DNAbin"
  time <- Sys.time() - time
  if (!quiet) (message(paste0("finished in ", format(time, digits = 2))))
  return(res)
}

filt_phmm <- function(s, model, min_score = 100, min_length = 1, max_indel = Inf, shave = TRUE, check_frame=TRUE, trim_ends=FALSE, ...) {
  s <- s[!s %in% as.raw(c(2, 4))] #Remove gaps
  vit <- aphid::Viterbi(model, s, odds = TRUE, type = "semiglobal", cpp = TRUE, residues = "DNA", ...=...)

  # Stop early if below score or no matching states
  if (vit$score < min_score | !any(vit$path == 1)) {
    return(NULL)
  }

  # Calculate longest match length
  rle_path <- rle(vit$path)
  rle_matches <- rle_path$lengths
  names(rle_matches) <- rle_path$values

  # Only count alignments over 10 bases to prevent bad alignments
  rle_matches <- rle_matches[!names(rle_matches)=="1" | rle_matches > 10]

  # If there is more than one matching segment, see if the gaps between them are viable
  if(sum(names(rle_matches) == "1") > 1){
    all_matches <- rle_matches[names(rle_matches) == "1"]
    match_ranges <- range(which(names(rle_matches) == "1"))
    all_between <- seq(match_ranges[1], match_ranges[2], 1)
    gap_lengths <- rle_matches[all_between[!all_between %in% which(names(rle_matches) == "1")]]

    # Check if gap lengths is divisible by 3
    if(check_frame & !all((gap_lengths %% 3)==0, na.rm = TRUE)){
      return(NULL)
    }
    # If the numbers between the 1 elements are less than max_indel combine with previous. Starting from second element!
    for(m in 2:length(rle_matches)){
      # Check if the current element is not a 1, but there is a 1 ahead and behind
      if(all((!names(rle_matches[m]) == "1"), (names(rle_matches[m-1]) == "1"), (names(rle_matches[m+1]) == "1"), na.rm =TRUE)){
        #check if the current element is below max_indel
        if(rle_matches[m] <  max_indel){
          # if so, add the numbers
          names(rle_matches)[m] <- "1"
          rle_matches[m] <- (rle_matches[m] + rle_matches[m-1])
        }
      } else if(names(rle_matches[m]) == "1" & names(rle_matches[m-1]) == "1"){
        rle_matches[m] <- (rle_matches[m] + rle_matches[m-1])
      }
    }
  }
  # Get longest match
  longest_match <- max(rle_matches[names(rle_matches) == "1"])

  # Return null if below min_length
  if (longest_match < min_length) {
    return(NULL)
  }

  # if shave is true, shave to alignment 2 - Maybe here is where i need to put the rolling match call?
  if (shave & any(vit$path==2)) {
    last <- match(c(0, 1), rev(vit$path)) - 1
    last <- min(last[!is.na(last)])  # Getting the min, ignores deletions in the middle
    begin <- match(c(0, 1), vit$path)
    begin <- min(begin[!is.na(begin)])
    s <- s[begin: (length(s) - last)]
    vit$path <- vit$path[begin:(length(vit$path)-last)]
  }

  # Insert gaps to pad sequence out to the alignment length
  out <- as.raw(vit$path)
  out[out %in% c("01", "02")] <- s
  out[out==00] <- as.raw(04)

  # Trim any single bases on each end
  if (is.numeric(trim_ends)){
    if(out[trim_ends] == as.raw(04)){
      out[1:trim_ends] <- as.raw(04)
    }
    if(out[length(out)-(trim_ends-1)]== as.raw(04)){
      out[length(out)-(trim_ends-1):length(trim_ends)] <- as.raw(04)
    }
  }
  return(out)
}



# Codon filters ---------------------------------------------------------------
#' Get Reading frame of sequences
#'
#' @param x Sequences in DNAStringset or DNAbin format
#' @param genetic_code A genetic code for the Amino acid translation. set to 'SGC4' for Invertebrate mitochondrial or see all known codes at Biostrings::GENETIC_CODE_TABLE
#' @param tryrc Whether the reverse complemement should be evaluated if no frame without stop codons was found in the forward orientation.
#' @param resolve_draws How draws should be resolved when multiple possible frames produce sequences with no stop codons.
#' Options are "remove" to completely remove the sequence, or "majority" to pick the most common frame from the entire alignment.
#'
#' @return
#' @export
#'
#' @import stringr
#' @importFrom Biostrings reverseComplement
#' @importFrom Biostrings translate
#' @importFrom Biostrings getGeneticCode
#' @importFrom methods is
#'
get_reading_frame <- function(x, genetic_code = NULL, tryrc=TRUE, resolve_draws="majority") {
  if(is.null(genetic_code)){
    stop("genetic_code must not be NULL, set to 'SGC4' for Invertebrate mitochondrial or see Biostrings::GENETIC_CODE_TABLE for other options")
  }
  # Convert to DNAStringSet
  if (methods::is(x, "DNAbin")) {
    x <- DNAbin2DNAstringset(x, remove_gaps=FALSE)
  }

  # Get reading frames for forward and reverse oriientations
  if(!tryrc){
    frames <- lapply(1:3, function(pos) subseq(x, start=pos))
  }else if (tryrc){
    frames <- c(lapply(1:3, function(pos) subseq(x, start=pos)),
                lapply(1:3, function(pos) subseq(Biostrings::reverseComplement(x), start=pos))
    )
  }
  #Translate all reading frames
  suppressWarnings(
    translated <- lapply(frames, Biostrings::translate, genetic.code = Biostrings::getGeneticCode(genetic_code), if.fuzzy.codon=c("solve", "X"))
  )

  #select the reading frames that contain 0 stop codons, or return NA
  reading_frame <- vector("integer", length=length(x))
  for (i in 1:length(x)){
    # Check forward frames first
    fvec <- c(stringr::str_count(as.character(translated[[1]][i]), "\\*"),
              stringr::str_count(as.character(translated[[2]][i]), "\\*"),
              stringr::str_count(as.character(translated[[3]][i]), "\\*"))
    if(sum(fvec==0)==1){
      # If only 1 appropriate frame for fwd direction
      reading_frame[i] <- which(fvec==0)
    } else if(sum(fvec==0)>1) {
      # If multiple appropriate frames for fwd direction
      reading_frame[i] <- 0
    } else if(sum(fvec==0)==0) {
      # If no appropriate frames for fwd direction
      # Try reverse direction or return NA
      if(tryrc){
        rvec <- c(stringr::str_count(as.character(translated[[4]][i]), "\\*"),
                  stringr::str_count(as.character(translated[[5]][i]), "\\*"),
                  stringr::str_count(as.character(translated[[6]][i]), "\\*"))
        if(sum(rvec==0)==1){
          #Check if only 1 appropriate frame for rev direction (return negative)
          reading_frame[i] <- -which(rvec==0)
        } else if(sum(rvec==0)>1) {
          #Check if multiple appropriate frames for rev direction
          reading_frame[i] <- 0
        }else if(sum(rvec==0)==0) {
          #Check if multiple appropriate frames for rev direction
          reading_frame[i] <- NA
        }
      } else {
        reading_frame[i] <- NA
      }
    }
  }
  # if resolve draws is majority, select the most common frame from across the whole dataset
  if (resolve_draws == "majority") {
    reading_frame[reading_frame==0] <- reading_frame[which.max(tabulate(reading_frame))]
  } else if (resolve_draws == "remove") {
    reading_frame[reading_frame==0] <- NA
  }
  return(reading_frame)
}


#' Filter sequences containing stop codons
#'
#' @param x Sequences in DNAStringset or DNAbin format
#' @param genetic_code A genetic code for the Amino acid translation. set to 'SGC4' for Invertebrate mitochondrial or see all known codes at Biostrings::GENETIC_CODE_TABLE
#' @param tryrc Whether the reverse complemement should be evaluated if no frame without stop codons was found in the forward orientation.
#' @param resolve_draws How draws should be resolved when multiple possible frames produce sequences with no stop codons.
#' Options are "remove" to completely remove the sequence, or "majority" to pick the most common frame from the entire alignment.
#'
#' @return
#' @export
#' @importFrom ape as.DNAbin
#' @importFrom Biostrings reverseComplement
#' @importFrom DECIPHER RemoveGaps
#' @importFrom methods is
#'
codon_filter <- function(x, genetic_code = NULL, tryrc=TRUE, resolve_draws="majority"){
  if(is.null(genetic_code)){
    stop("genetic_code must not be NULL, set to 'SGC4' for Invertebrate mitochondrial or see Biostrings::GENETIC_CODE_TABLE for other options")
  }
  # Convert to DNAStringSet
  if (methods::is(x, "DNAbin")) {
    x <- DNAbin2DNAstringset(x, remove_gaps=FALSE)
    format <- "DNAbin"
  } else if(methods::is(x, "DNAStringSet")){
    format <- "DNAStringSet"
  } else {
    stop("x must be a DNAbin or DNAStringSet")
  }

  #Get reading frames
  frames <- get_reading_frame(DECIPHER::RemoveGaps(x), genetic_code = genetic_code, tryrc = tryrc, resolve_draws = resolve_draws)

  # Check if any sequences need RC (negative reading frame)
  to_rc <- sign(frames)==-1
  to_rc[is.na(to_rc)] <- FALSE
  if (any(to_rc)){
    message(sum(to_rc), " Sequences reverse complemented as no forward match was found")
    x[to_rc] <- Biostrings::reverseComplement(x[to_rc])
  }

  if(format=="DNAbin"){
    out <- ape::as.DNAbin(x[!is.na(frames)])
  } else if(format=="DNAStringSet"){
    out <- x[!is.na(frames)]
  }
  message(paste0(length(x) - length(out), " Sequences containing stop codons removed"))
  return(out)
}

#' Codon entropy
#'
#' @param x Sequences in DNAStringset or DNAbin format
#' @param genetic_code A genetic code for the Amino acid translation. set to 'SGC4' for Invertebrate mitochondrial or see all known codes at Biostrings::GENETIC_CODE_TABLE
#' @param tryrc Whether the reverse complemement should be evaluated if no frame without stop codons was found in the forward orientation.
#' @param codon_filter Whether `taxreturn::codon_filter` should be run first to remove sequences containing stop codons or frameshifts.
#' @param resolve_draws How draws should be resolved when multiple possible frames produce sequences with no stop codons.
#' Options are "remove" to completely remove the sequence, or "majority" to pick the most common frame from the entire alignment.
#' @param method the method employed to estimate entropy. see `?entropy::entropy` for more details
#'
#' @return
#' @export
#' @import purrr
#' @importFrom entropy entropy
#' @importFrom methods is
#'
#'
codon_entropy <- function(x, genetic_code = NULL, tryrc = TRUE, codon_filter = TRUE, resolve_draws = "majority", method = "ML") {
  if(is.null(genetic_code)){
    stop("genetic_code must not be NULL, set to 'SGC4' for Invertebrate mitochondrial or see Biostrings::GENETIC_CODE_TABLE")
  }
  if (methods::is(x, "DNAbin")) {
    x <- DNAbin2DNAstringset(x, remove_gaps=FALSE)
  }
  #Filter out sequences with stop codons
  if(codon_filter){
    x <- codon_filter(x, genetic_code = genetic_code, tryrc=tryrc)
  }

  #subset to the reading frame
  pos <- get_reading_frame(x, genetic_code = genetic_code, tryrc = tryrc, resolve_draws = resolve_draws)

  F_frames <-  as.character(subseq(x, start= pos))

  ent <- vector("list", length=length(F_frames))
  for (l in 1:length(F_frames)){
    ent[[l]] <- c(
      entropy::entropy(table(purrr::map_chr(seq(1, nchar(F_frames[l]), 3), function(i) substr(F_frames[l], i, i))), method=method),
      entropy::entropy(table(purrr::map_chr(seq(2, nchar(F_frames[l]), 3), function(i) substr(F_frames[l], i, i))), method=method),
      entropy::entropy(table(purrr::map_chr(seq(3, nchar(F_frames[l]), 3), function(i) substr(F_frames[l], i, i))), method=method)
    )
    names(ent[[l]]) <- c("pos1", "pos2", "pos3")
  }
  names(ent) <- names(x)
  return(ent)
}


# kmer screening -------------------------------------------------------------
#' Kmer screening function
#'
#' @param seqs A DNAbin object
#' @param model A Profile Hidden Markov model ("PHMM" object) generated by `aphid::derivePHMM` to screen the sequences against.
#' An already derived model of COI can be loaded using `data("model", package="taxreturn")`
#' @param threshold The maximum kmer distance allowed from the reference model before a sequence is discarded.
#' @param k The k-mer size to be used for calculating the distance matrix, parsed to kmer::mbed. Note that high values of k may be slow to compute and use a lot of memory due to the large numbers of calculations required, particularly when the residue alphabet is also large.
#' @param quiet Whether progress should be printed to the console.
#'
#' @return
#' @export
#' @importFrom kmer mbed
#' @importFrom aphid generate
#'
kmer_screen <- function(seqs, model, threshold = 0.3, k = 5, quiet=FALSE){
  # Check inputs
  if(!class(model) == "PHMM") {
    stop("Model must be of class PHMM")
  }
  if(!class(seqs) == "DNAbin") {
    stop("Seqs must be of class DNAbin")
  }

  # Generate a reference sequence from the model to align against
  seed_seq <- char2DNAbin(paste(aphid::generate(model, model$size, random=FALSE), collapse=""))
  names(seed_seq) <- "SEED"

  # Align against seed sequence using mbed
  mbed_dist <- kmer::mbed(c(seed_seq, seqs), seeds = 1, k = k, residues = NULL, gap = "-",
                          counts = FALSE)[,]

  # Return only sequences below kmer distance threshold
  seqs_to_keep <- names(mbed_dist)[mbed_dist < threshold]
  seqs_to_keep <- seqs_to_keep[seqs_to_keep %in% names(seqs)]

  out <- seqs[seqs_to_keep]
  if(length(out) > 0){
    if(!quiet){ message(length(seqs[!names(seqs) %in% names(out)]), " sequences >", threshold, " ", k,"-mer distance removed")}
    return(out)
  } else{
    if(!quiet){ warning("All sequences are >", threshold, " ", k,"-mer distance and were removed")}
    return(NULL)
  }
  return()
}

#' Closest kmer distance
#' This function checks the kmer distance between all the sequences in a DNAbin and a reference PHMM model
#'
#' @param seqs A DNAbin object
#' @param model A Profile Hidden Markov model ("PHMM" object) generated by `aphid::derivePHMM` to screen the sequences against.
#' An already derived model of COI can be loaded using `data("model", package="taxreturn")`
#' @param threshold The maximum kmer distance allowed from the reference model before a sequence is discarded.
#' @param k The k-mer size to be used for calculating the distance matrix, parsed to kmer::mbed. Note that high values of k may be slow to compute and use a lot of memory due to the large numbers of calculations required, particularly when the residue alphabet is also large.
#' @param quiet Whether progress should be printed to the console.
#'
#' @return
#' @export
#'
#' @importFrom kmer mbed
#' @importFrom aphid generate
#'
closest_seq <- function(seqs, model, threshold, k=5, quiet=FALSE){
  # Check inputs
  if(!class(model) == "PHMM") {
    stop("Model must be of class PHMM")
  }
  if(!class(seqs) == "DNAbin") {
    stop("Seqs must be of class DNAbin")
  }

  # Generate a reference sequence from the model to align against
  seed_seq <- char2DNAbin(paste(aphid::generate(model, model$size), collapse=""))
  names(seed_seq) <- "SEED"

  # Align against seed sequence using mbed
  mbed_dist <- kmer::mbed(c(seed_seq, seqs), seeds = 1, k = k, residues = NULL,
                          counts = FALSE)[,]
  if(any(mbed_dist < threshold)){
    out <- unname(which.min(mbed_dist[!names(mbed_dist) == "SEED"]))
  } else (out <- NULL)
  return(out)
}

chunk_seqs <- function(x, split_length){
  n <- round(length(x)/split_length)
  chunk <- function(x,n) split(x, cut(seq_along(x), n, labels = FALSE))
  if(n >1 ){
    splits <- chunk(x, n)
  } else (splits <- x)

  #Check no chunks are just all gaps
  no_gaps<- lapply(splits, function(s) s[!(s %in% as.raw(c(2, 4, 240)))])
  splits <- splits[sapply(no_gaps, length) > 0]

  class(splits) <- "DNAbin"
  return(splits)
}

subset_long_seq <- function(x, model, split_length, threshold=0.3, k=5, quiet=FALSE){
  # Split sequences into chunks
  splits <- chunk_seqs(x, split_length=split_length)
  if(!is.list(splits))(return(x))

  # Check all chunks are above value of k
  no_gaps<- lapply(splits, function(s) s[!(s %in% as.raw(c(2, 4, 240)))])
  splits <- splits[sapply(no_gaps, length) > (k+1)]

  # find chunk with closest kmer distance
  min_split <- closest_seq(splits, model = model, threshold = threshold, k = k, quiet = quiet)

  # Return that chunk and its adjacent neighbours - within bounds of splits
  chunks_to_keep <- c(min_split-1,min_split, min_split+1)
  chunks_to_keep <- chunks_to_keep[(chunks_to_keep > 0 & chunks_to_keep <= length(splits))]

  # Return concatenated subsequence
  out <- unlist(splits[chunks_to_keep])
  return(out)
}

# Prune group sizes -------------------------------------------------------
#' Prune group sizes
#'
#' @param x A DNAbin or DNAStringset object
#' @param max_group_size The maximum number of sequences with the same taxonomic annotation to keep
#' @param dedup Whether sequences with identical taxonomic name and nucleotide bases sequences should be discarded first
#' @param discardby How sequences from groups with size above max_group_size should be discarded.
#' Options include "length" (Default) which will discard sequences from smallest to largest until the group is below max_group_size,
#' "random" which will randomly pick sequences to discard until the group is below max_group_size.
#' @param prefer A vector of sequence names that will be preferred when subsampling groups when discardby=random,
#' or prefered when breaking ties in sequences of the same length when discardby=length. For instance high quality in-house sequences.
#' @param quiet Whether progress should be printed to the console.
#' @return
#' @export
#'
#' @import dplyr
#' @import stringr
#' @importFrom tibble as_tibble
#' @importFrom tidyr separate
#' @importFrom openssl md5
#' @importFrom ape as.DNAbin
#' @importFrom ape base.freq
#' @importFrom methods is
#'
prune_groups <- function(x, max_group_size = 5, dedup = TRUE, discardby = "length", prefer=NULL, quiet = FALSE) {
  # Convert to DNAbin
  if (!methods::is(x, "DNAbin")) {
    x <- ape::as.DNAbin(x)
    if (all(is.na(ape::base.freq(x)))) {stop("Error: Object is not coercible to DNAbin \n")}
  }
  if (!is.null(prefer) & !is.character(prefer)){
    stop("prefer must be either NULL or a vector of sequence names to prefer")
  }

  # Remove duplicate sequences
  if (dedup) {
    dup <- length(x)
    taxids <- names(x) %>%
      stringr::str_remove("^.*;")

    ## Consider taxonomic name and sequence identity in deduplication
    hashes <- purrr::map2(x, taxids, ~{
      openssl::md5(paste(c(.y, as.vector(.x)), collapse=""))
    }) %>%
      unlist()

    # get list of all duplicated hashes
    dupes <- unique(hashes[duplicated(hashes)])
    remove <- logical(length(x))
    for (i in 1:length(dupes)) {
      index <- which(hashes %in% dupes[i])
      # Check if in prefered - If so keep first element in the prefered
      if (is.character(prefer) & any(names(x)[index] %in% prefer)){
        keep <- index[names(x)[index] %in% prefer][1]
      } else {
        # otherwise just pick first element
        keep <- index[1]
      }
      remove[index[!index %in% keep]] <- TRUE
    }
    x <- x[!remove]
    if (!quiet) cat(paste0((dup - length(x)), " duplicate sequences removed \n"))
  }

  # Remove sequences from groups where more species names than max_group_size
  groups <- names(x) %>%
    stringr::str_split_fixed(";", n = 2) %>%
    tibble::as_tibble(.name_repair = ~ c("acc", "taxon")) %>%
    dplyr::pull(taxon) %>%
    openssl::md5()
  groupCounts <- table(groups) # Count number of seqs per group
  u_groups <- names(groupCounts) # Get unique groups

  remove <- logical(length(x))
  # Random discarding
  if (discardby == "random") {
    for (i in which(groupCounts > max_group_size)) {
      index <- which(groups == u_groups[i])
      # Deal with prefered
      if (is.character(prefer) & any(names(x)[index] %in% prefer)){
        in_pref <- index[names(x)[index] %in% prefer]
        # Check if can sample just from prefered, or need a mix of the two
        if(in_pref >= max_group_size){
          keep <- sample(
            x = in_pref,
            size = max_group_size,
            replace = FALSE
          )
        } else{
          to_sample <- max_group_size - length(in_pref)
          keep <- c(in_pref,
                    sample(
                      x = index[-in_pref],
                      size = to_sample,
                      replace = FALSE
                    ))
        }
      } else {
        # otherwise just take random sample
        keep <- sample(
          x = index,
          size = max_group_size,
          replace = FALSE
        )
      }
      remove[index[-keep]] <- TRUE
    }
    # length discarding
  } else if (discardby == "length") {
    for (i in which(groupCounts > max_group_size)) {
      index <- which(groups == u_groups[i])
      rem <- sapply(x[index], function(s) length(s) - sum(s == as.raw(c(4)))) # Get lengths
      names(rem) <- index
      rem <- sort(rem, decreasing = TRUE)

      # deal with prefered
      if (is.character(prefer) & any(names(x)[index] %in% prefer)){
        in_pref <- index[names(x)[index] %in% prefer]
        non_pref <- index[!names(x)[index] %in% prefer]

        # Get the minimum length of sequences that are being dropped
        min_len <- min(rem[1:max_group_size])

        # Check if there are mixed prefered and non prefered at that length
        mixed_pref <- rem[names(rem) %in% in_pref] == min_len
        mixed_pref <- names(mixed_pref)[mixed_pref]
        mixed_non_pref <- rem[names(rem) %in% non_pref] == min_len
        mixed_non_pref <- names(mixed_non_pref)[mixed_non_pref]

        if((length(mixed_pref) > 0) & (length(mixed_pref) > 0)){
          # re-sort vector to prefer
          sample_from <- as.integer(c(names(rem)[rem > min_len], mixed_pref, mixed_non_pref, names(rem)[rem < min_len]))
          keep <- as.integer(sample_from[1:max_group_size])
        } else {
          # otherwise just take the longest
          keep <- as.integer(names(rem[1:max_group_size]))
        }
      } else{
        keep <- as.integer(names(rem[1:max_group_size]))
      }
      remove[index[!index %in% keep]] <- TRUE
    }
  }
  x <- x[!remove]
  if (!quiet) cat(paste0(sum(remove), " sequences pruned from over-represented groups"))
  return(x)
}

# Mixed clusters -----------------------------------------------------
#' Get mixed clusters
#'
#' @description Cluster sequences at a certain taxonomic similarity, and find clusters that contain mixed taxonomic names,
#' @description Note, it is recommended to set a unique seed using set.seed()
#' @param x	 A DNAbin list object whose names include NCBItaxonomic identification numbers.
#' @param db A taxonomic database from `get_ncbi_taxonomy` or `get_ott_lineage`
#' @param rank The taxonomic rank to check clusters at, accepts a character such as "order", or vector of characters such as c("species", "genus").
#' If "all", the clusters will be checked at all taxonomic ranks available.
#' @param threshold numeric between 0 and 1 giving the OTU identity cutoff for clustering. Defaults to 0.97.
#' @param rngseed (Optional) A single integer value passed to set.seed, which is used to fix a seed for reproducibly random number generation for the kmeans clustering.
#' If set to FALSE, then no fiddling with the RNG seed is performed, and it is up to the user to appropriately call set.seed beforehand to achieve reproducible results.
#' @param confidence The minimum confidence value for a mixed cluster to be flagged. For example, if confidence = 0.8 (the default value)
#'  a cluster will only be flagged if the taxonomy of a sequence within the cluster differs from at least four other independent sequences in its cluster.
#'  @param nstart how many random sets should be chosen for `kmeans`, It is recommended to set the value of nstart to at least 20.
#'  While this can increase computation time, it can improve clustering accuracy considerably.
#' @param return What type of data about the data should be returned. Options include:
#' Consensus - The consensus taxonomy for each cluster and associated confidence level
#' All - Return all taxa in mixed clusters and their sequence accession numbers
#' Count - Return counts of all taxa within each cluster
#' @param k integer giving the k-mer size used to generate the input matrix for k-means clustering.
#' @param quiet logical indicating whether progress should be printed to the console.
#' @param ... further arguments to pass to kmer::otu.
#'
#' @return
#' @export
#' @import dplyr
#' @importFrom kmer otu
#' @importFrom tibble rownames_to_column
#' @importFrom methods as
#' @examples
#' \dontrun{
#' seqs <- ape::read.FASTA("test.fa.gz")
#'
#' # NCBI taxonomy
#' mixed <- get_mixed_clusters(seqs, db, rank="species", threshold=0.99, confidence=0.8, quiet=FALSE)
#'
#' # OTT taxonomy
#' seqs <- map_to_ott(
#' seqs, dir="ott3.2", from="ncbi",
#' resolve_synonyms=TRUE, filter_bads=TRUE, remove_na = TRUE, quiet=FALSE
#' )
#'
#' mixed <- get_mixed_clusters(
#' seqs, db, rank="species",
#' threshold=0.99, confidence=0.6, quiet=FALSE
#' )
#' }
#'
get_mixed_clusters <- function (x, db, rank = "order", threshold = 0.97, rngseed = FALSE, confidence = 0.8, return = "consensus", k=5, quiet = FALSE, ...) {
  if(missing(x)) {stop("Error: x is required")}

  #Check inputs
  if(!is.numeric(threshold) | !dplyr::between(threshold, 0,1)) { stop("Threshold must be a numeric between 0 and 1")}
  if(!is.numeric(confidence) | !dplyr::between(confidence, 0,1)) { stop("Confidence must be a numeric between 0 and 1")}
  rank <- tolower(rank)
  return <- tolower(return)
  if(!return %in% c("consensus", "all", "counts")){stop("Return must be one of: 'consensus', 'all', or 'counts'")}
  if (methods::as(rngseed, "logical")) {
    set.seed(rngseed)
    if (!quiet) {
      message("`set.seed(", rngseed, ")` was used to initialize repeatable random subsampling.")
      message("Please record this for your records so others can reproduce.")
      message("Try `set.seed(", rngseed, "); .Random.seed` for the full vector",
              sep = "")
    }
  } else if (!quiet) {message("You set `rngseed` to FALSE. Make sure you've set & recorded\n",
                              " the random seed of your session for reproducibility.\n",
                              "See `?set.seed`\n")}

  #Get lineage
  if(attr(db, "type")  == "ncbi"){
    source <- "ncbi"
    lineage <- taxreturn::get_ncbi_lineage(x = x, db = db)
  } else if(attr(db, "type")  == "OTT"){
    source <- "OTT"
    lineage <- taxreturn::get_ott_lineage(x = x, db = db)
  } else (stop("db type is not supported"))

  # Cluster OTUS
  if (is.null(attr(x, "OTU"))) {
    if (!quiet) {cat(paste0("Clustering OTUs at ", (threshold*100), "%  similarity \n"))}
    otus <- kmer::otu(x, k=k , threshold = threshold, ...)
  } else {
    if (!quiet) {cat("Obtaining OTU membership from input object\n")}
    otus <- attr(x, "OTU")
    stopifnot(length(x) == length(otus))
  }
  if(length(unique(otus))==1) {
    warning("Only one unique cluster")
    return(NULL)
  }
  if (!quiet) {cat("Comparing lineage metadata within OTUs\n")}

  # Get mixed clusters
  find_mixed <- function(y, return) {
    # Ensure no duplicated accessions+names to bias confidence
    hashes <- paste0(gsub("\\|.*$", "\\1", names(y)), y)
    yu <- y[!duplicated(hashes)]
    if (length(unique(yu)) < 2) {
      return(NULL)
    }
    # Tabulate taxon names
    tab <- sort(table(yu), decreasing = TRUE)

    if(return == "consensus"){
      consensus <- names(tab)[1]
      consensus_taxid <- gsub("^.*\\|", "\\1", names(y)[y==consensus][1])
      mixed <- y != consensus #potential misannotated
      mixedu <- yu != consensus
      nu <- length(mixedu)

      #Check if there is a clear consensus
      if (tab[1] == tab[2]){
        consensus <- NA
        consensus_taxid <- NA
      }
      res <- data.frame(listed = y[mixed],
                        consensus = rep(consensus, sum(mixed)),
                        consensus_taxid = rep(consensus_taxid,sum(mixed)),
                        confidence = sum(!mixedu)/nu, cluster_size = nu,
                        stringsAsFactors = FALSE)  %>%
        tibble::rownames_to_column("Acc")
    } else if (return=="counts"){
      res <- data.frame(tax_name = names(tab),
                        count =as.numeric(tab), stringsAsFactors = FALSE)
    } else if (return=="all"){
      res <- data.frame(Acc =  gsub("\\|.*$", "\\1", names(y)),
                        tax_id = gsub("^.*\\|", "\\1", names(y)),
                        listed = as.character(y), stringsAsFactors = FALSE)
    }

    return(res)
  }

  # Loop over rank
  results <- vector("list", length=length(rank))
  for (i in 1:length(rank)){
    lins <- lineage %>%
      dplyr::select(!!rank[i]) %>%
      dplyr::pull(!!rank[i])
    if(length(lins[is.na(lins)]) >0 & !quiet){warning("ignoring ", length(lins[is.na(lins)]), " sequence/s with no taxonomic data for ", rank[i])}
    names(lins) <- lineage$Acc
    f <- as.factor(otus[!is.na(lins)])
    lins <- lins[!is.na(lins)]

    splitlist <- split(lins, f)
    splitlist <- splitlist[tabulate(f) > 2]

    mixedtab <- lapply(splitlist, find_mixed, return)
    mixedtab <- mixedtab[!vapply(mixedtab, is.null, logical(1))]
    if (length(mixedtab) == 0) {
      if (!quiet) {cat("No mixed clusters at", rank[i],   "rank \n")}
      results[[i]] <-  as.data.frame(NULL)
    } else if (length(mixedtab) > 0){

      mixedtab <- dplyr::bind_rows(mixedtab, .id="cluster")
      if(rank[i] == "species"){
        if(return == "consensus"){
          #Return binomials if species rank is selected
          mixedtab <- mixedtab %>%
            dplyr::left_join(lineage %>% dplyr::select(Acc, genus)) %>%
            dplyr::mutate(listed = paste0(genus, " ", listed),
                          consensus  = paste0(genus," ", consensus)) %>%
            dplyr::select(-genus)
        } else if(return == "all"){
          mixedtab <- mixedtab %>%
            dplyr::left_join(lineage %>%
                               dplyr::select(Acc, genus) %>%
                               tidyr::separate(Acc, into=c("Acc", "tax_id"), sep="\\|"), by=c("Acc", "tax_id")) %>%
            dplyr::mutate(listed = paste0(genus, " ", listed)) %>%
            dplyr::select(-genus)
        }
      }
      if(return == "consensus"){
        mixedtab <- mixedtab[mixedtab$confidence >= confidence, ]
      }
      if (nrow(mixedtab) == 0) {
        if (!quiet) {cat("No mixed clusters at", rank[i],   "rank \n")}
        results[[i]] <-  as.data.frame(NULL)
      } else if(nrow(mixedtab) > 0 ) {
        if(return == "consensus"){
          mixedtab <- mixedtab[order(mixedtab$confidence, decreasing = TRUE), ]
        }
        if (!quiet) {cat("identified", length(unique(mixedtab$cluster)), "mixed clusters at", rank[i],   "rank \n")}
        results[[i]] <-  mixedtab %>%
          dplyr::mutate(rank = rank[i],
                        threshold = threshold) %>%
          dplyr::mutate_if(is.factor, as.character)

      }
    }
  }

  out <- dplyr::bind_rows(results)
  if (nrow(out)==0) {
    return(NULL)
  } else (return(out))
}
