
#' Clean Sequences with PHMM (DEPRECATED)
#'
#' @param x A DNAbin or DNAStringset object
#' @param model A profile hidden Markov model (a "PHMM" object) generated by the aphid R package to align the sequences to.
#' @param min_score The minimum specificity (log-odds score for the optimal alignment) between the query sequence and the PHMM model for the sequence to be retained in the output object.
#' @param shave Whether bases that are outside (to the left or right) of the PHMM object should be shaved from the outputs.
#' @param maxNs The max number of ambiguous N bases to retain
#' @param cores The number of CPUs to parallelize the operation over
#' @param quiet Whether progress should be printed to the console.
#' @param progress Whether a progress bar should be printed.
#'
#' @import stringr
#' @import parallel
#' @importFrom pbapply pblapply
#' @importFrom insect subset.DNAbin
#' @importFrom ape as.DNAbin
#' @importFrom ape base.freq
#' @importFrom ape as.character.DNAbin
#' @importFrom methods is
#' @return
#' @export
#'
clean_seqs <- function(x, model, min_score = 100, shave = TRUE, maxNs = 0, cores = 1,
                       quiet = FALSE, progress = FALSE) {
  .Deprecated("taxreturn::map_to_model", package="taxreturn",  old = as.character(sys.call(sys.parent()))[1L])
  time <- Sys.time() # get time

  # Convert to DNAbin
  if (!methods::is(x, "DNAbin")) {
    x <- ape::as.DNAbin(x)
    if (all(is.na(ape::base.freq(x)))) {stop("Error: Object is not coercible to DNAbin \n")}
  }
  if (!methods::is(model, "PHMM")) {
    stop("Model needs to be a PHMM object")
  }

  nseq <- length(x)

  if (cores == 1 && progress == TRUE) {
    requireNamespace("pbapply", quietly = TRUE)
    x <- pbapply::pblapply(x, filt_phmm, model, min_score)
  } else if (cores == 1 && progress == FALSE) {
    x <- lapply(x, filt_phmm, model, min_score)
  } else if (cores > 1 && progress == TRUE) {
    stop("Progress bar currently not supported for multithreading")
  } else {
    navailcores <- parallel::detectCores()
    if (identical(cores, "autodetect")) cores <- navailcores - 1
    if (!(mode(cores) %in% c("numeric", "integer"))) stop("Invalid 'cores'")
    if (cores > navailcores) stop("Number of cores is more than available")

    if (cores > 1) {
      if (!quiet) cat("Multithreading with", cores, "cores\n")

      cores <- parallel::makeCluster(cores, outfile = "out.txt")
      # parallel::clusterExport(cores, c("model", "min_score"))
      junk <- parallel::clusterEvalQ(cores, sapply(c("aphid", "insect", "ape"), require, character.only = TRUE)) # Discard result

      x <- parallel::parLapply(cores, x, filt_phmm, model, min_score)
      parallel::stopCluster(cores)
    } else {
      x <- lapply(x, filt_phmm, model, min_score)
    }
  }

  discards <- sapply(x, is.null)
  nseq <- sum(!discards)

  if (nseq > 0) {
    if (!quiet) cat("Retained", nseq, "sequences after alignment to PHMM\n")
    scores <- unlist(lapply(x, function(s) attr(s, "score")), use.names = FALSE)
    x <- x[!discards]
    x <- ape::as.DNAbin(ape::as.character.DNAbin(x))
  } else {
    if (!quiet) cat("None of the sequences met PHMM specificity criteria. Returning NULL\n")
    x <- NULL
  }
  if (!quiet) cat("Filtering ambiguous sequences\n")
  discards <- sapply(x, function(s) sum(s == 0xf0) / length(s)) > maxNs
  x <- insect::subset.DNAbin(x, subset = !discards)
  if (!quiet) cat(length(x), "sequences retained after applying ambiguity filter\n")
  if (!quiet) cat("Bases overhanging PHMM shaved from alignment\n")
  if (!quiet) cat("Done\n")
  time <- Sys.time() - time
  if (!quiet) (message(paste0("finished in ", format(time, digits = 2))))
  return(x)
}

# Propagate taxonomic assignments to species level ------------------------

#' Propagate taxonomy (DEPRECATED)
#'
#' @param tax A taxonomy table
#' @param from The taxonomic rank to propagate below
#'
#' @return
#' @export
#'
#'
propagate_tax <- function(tax, from = "Family") {
  .Deprecated(new="seqateurs::na_to_unclassified", package="seqateurs", old="taxreturn::propagate_tax")
  col.prefix <- substr(colnames(tax), 1, 1) # Assumes named Kingdom, ...

  # Highest level to propagate from
  if (from == "Phylum") (start <- 2)
  if (from == "Class") (start <- 3)
  if (from == "Order") (start <- 4)
  if (from == "Family") (start <- 5)
  if (from == "Genus") (start <- 6)
  if (from == "Species") (start <- 7)

  # Propagate
  for (col in seq(start, ncol(tax))) {
    prop <- is.na(tax[, col]) & !is.na(tax[, col - 1])
    newtax <- tax[prop, col - 1]
    needs.prefix <- !grepl("^[A-z]__", newtax)
    newtax[needs.prefix] <- paste(col.prefix[col - 1], newtax[needs.prefix], sep = "__")
    tax[prop, col] <- newtax
  }
  tax
}
