
#' Clean Sequences with PHMM (DEPRECATED)
#'
#' @param x A DNAbin or DNAStringset object
#' @param model A profile hidden Markov model (a "PHMM" object) generated by the aphid R package to align the sequences to.
#' @param min_score The minimum specificity (log-odds score for the optimal alignment) between the query sequence and the PHMM model for the sequence to be retained in the output object.
#' @param shave Whether bases that are outside (to the left or right) of the PHMM object should be shaved from the outputs.
#' @param maxNs The max number of ambiguous N bases to retain
#' @param cores The number of CPUs to parallelize the operation over
#' @param quiet Whether progress should be printed to the console.
#' @param progress Whether a progress bar should be printed.
#'
#' @import stringr
#' @import parallel
#' @importFrom pbapply pblapply
#' @importFrom insect subset.DNAbin
#' @importFrom ape as.DNAbin
#' @importFrom ape base.freq
#' @importFrom ape as.character.DNAbin
#' @importFrom methods is
#' @return
#' @export
#'
clean_seqs <- function(x, model, min_score = 100, shave = TRUE, maxNs = 0, cores = 1,
                       quiet = FALSE, progress = FALSE) {
  .Deprecated("taxreturn::map_to_model", package="taxreturn",  old = as.character(sys.call(sys.parent()))[1L])
  time <- Sys.time() # get time

  # Convert to DNAbin
  if (!methods::is(x, "DNAbin")) {
    x <- ape::as.DNAbin(x)
    if (all(is.na(ape::base.freq(x)))) {stop("Error: Object is not coercible to DNAbin \n")}
  }
  if (!methods::is(model, "PHMM")) {
    stop("Model needs to be a PHMM object")
  }

  nseq <- length(x)

  if (cores == 1 && progress == TRUE) {
    requireNamespace("pbapply", quietly = TRUE)
    x <- pbapply::pblapply(x, filt_phmm, model, min_score)
  } else if (cores == 1 && progress == FALSE) {
    x <- lapply(x, filt_phmm, model, min_score)
  } else if (cores > 1 && progress == TRUE) {
    stop("Progress bar currently not supported for multithreading")
  } else {
    navailcores <- parallel::detectCores()
    if (identical(cores, "autodetect")) cores <- navailcores - 1
    if (!(mode(cores) %in% c("numeric", "integer"))) stop("Invalid 'cores'")
    if (cores > navailcores) stop("Number of cores is more than available")

    if (cores > 1) {
      if (!quiet) cat("Multithreading with", cores, "cores\n")

      cores <- parallel::makeCluster(cores, outfile = "out.txt")
      # parallel::clusterExport(cores, c("model", "min_score"))
      junk <- parallel::clusterEvalQ(cores, sapply(c("aphid", "insect", "ape"), require, character.only = TRUE)) # Discard result

      x <- parallel::parLapply(cores, x, filt_phmm, model, min_score)
      parallel::stopCluster(cores)
    } else {
      x <- lapply(x, filt_phmm, model, min_score)
    }
  }

  discards <- sapply(x, is.null)
  nseq <- sum(!discards)

  if (nseq > 0) {
    if (!quiet) cat("Retained", nseq, "sequences after alignment to PHMM\n")
    scores <- unlist(lapply(x, function(s) attr(s, "score")), use.names = FALSE)
    x <- x[!discards]
    x <- ape::as.DNAbin(ape::as.character.DNAbin(x))
  } else {
    if (!quiet) cat("None of the sequences met PHMM specificity criteria. Returning NULL\n")
    x <- NULL
  }
  if (!quiet) cat("Filtering ambiguous sequences\n")
  discards <- sapply(x, function(s) sum(s == 0xf0) / length(s)) > maxNs
  x <- insect::subset.DNAbin(x, subset = !discards)
  if (!quiet) cat(length(x), "sequences retained after applying ambiguity filter\n")
  if (!quiet) cat("Bases overhanging PHMM shaved from alignment\n")
  if (!quiet) cat("Done\n")
  time <- Sys.time() - time
  if (!quiet) (message(paste0("finished in ", format(time, digits = 2))))
  return(x)
}

# Propagate taxonomic assignments to species level ------------------------

#' Propagate taxonomy (DEPRECATED)
#'
#' @param tax A taxonomy table
#' @param from The taxonomic rank to propagate below
#'
#' @return
#' @export
#'
#'
propagate_tax <- function(tax, from = "Family") {
  .Deprecated(new="seqateurs::na_to_unclassified", package="seqateurs", old="taxreturn::propagate_tax")
  col.prefix <- substr(colnames(tax), 1, 1) # Assumes named Kingdom, ...

  # Highest level to propagate from
  if (from == "Phylum") (start <- 2)
  if (from == "Class") (start <- 3)
  if (from == "Order") (start <- 4)
  if (from == "Family") (start <- 5)
  if (from == "Genus") (start <- 6)
  if (from == "Species") (start <- 7)

  # Propagate
  for (col in seq(start, ncol(tax))) {
    prop <- is.na(tax[, col]) & !is.na(tax[, col - 1])
    newtax <- tax[prop, col - 1]
    needs.prefix <- !grepl("^[A-z]__", newtax)
    newtax[needs.prefix] <- paste(col.prefix[col - 1], newtax[needs.prefix], sep = "__")
    tax[prop, col] <- newtax
  }
  tax
}


# Fetchseqs function ----------------------------------------------

#' Fetchseqs function (DEPRECATED)
#'
#' @param x A taxon name or vector of taxon names to download sequences for.
#' @param database The database to download from. For NCBI GenBank this currently onlt accepts the arguments 'nuccore' or 'genbank' which is an alias for nuccore.
#' Alternatively sequences can be downloaded from the Barcode of Life Data System (BOLD) using 'bold'
#' @param marker The barcode marker used as a search term for the database. If you are targetting a gene, adding a suffix \[GENE\] will increase the search selectivity.
#' The default for Genbank is 'COI\[GENE\] OR COX1\[GENE\] OR COXI\[GENE\]', while the default for BOLD is 'COI-5P'.
#' If this is set to "mitochondria" and database is 'nuccore', or 'genbank'it will download mitochondrial genomes only.
#' If this is set to "genome" and database is 'nuccore', or 'genbank'it will download complete genome sequences only.
#' @param downstream Instead of search for the query sequence, this provides the option of instead searching for a downstream taxonomic rank.
#' This is useful for big queries where >100k sequences will be downloaded. For example, when x is 'Insecta', and downsteam is Order, this will download all Orders within insecta and thus not overload the query. Default is FALSE.
#' @param output The output format for the taxonomy in fasta headers.
#' Options include "h" for full heirarchial taxonomy (SeqID;Domain;Phylum;Class;Order;Family;Genus;Species),
#' "binom" for just genus species binomials (SeqID;Genus Species),
#' "bold" for BOLD taxonomic ID only (SeqID;BoldTaxID),
#' "gb" for genbank taxonomic ID (SeqID;GBTaxID),
#' "gb-binom" which outputs Genus species binomials, as well as genbank taxonomic ID's, and translates all BOLD taxonomic ID's to genbank taxonomic ID's in the process,
#' or "standard" which outputs the default format for each database. For bold this is `sampleid|species name|markercode|genbankid` while for genbank this is `Accession Sequence definition`
#' @param min_length The maximum length of the query sequence to return. Default 1.
#' @param max_length The maximum length of the query sequence to return.
#' This can be useful for ensuring no off-target sequences are returned. Default 2000.
#' @param subsample (Numeric) return a random subsample of sequences from the search.
#' @param out_dir Output directory to write fasta files to
#' @param compress Option to compress output fasta files using gzip
#' @param force Option to overwrite files if they already exist
#' @param chunk_size Split up the queries made (for genbank), or returned records(for BOLD) into chunks of this size to avoid overloading API servers.
#' if left NULL, the default for genbank searches will be 10,000 for regular queries, 1,000 if marker is "mitochondria", and 1 if marker is "genome"
#' For BOLD queries the default is 100,000 returned records
#' @param multithread Whether multithreading should be used, if TRUE the number of cores will be automatically detected, or provided a numeric vector to manually set the number of cores to use
#' Note, the way this is currently implemented, a seperate worker thread is assigned to each taxon, therefore multithreading will only work
#' if x is a vector, or of downstream is being used.
#' @param quiet Whether progress should be printed to the console.
#' @param progress A logical, for whether or not to print a progress bar when multithread is true. Note, this will slow down processing.
#'
#' @import dplyr
#' @import stringr
#' @import purrr
#' @import future
#' @import furrr
#' @importFrom taxize downstream
#' @importFrom methods as
#'
#' @return
#' @export
#'
fetchSeqs <- function(x, database, marker = NULL, downstream = FALSE,
                      output = "h", min_length = 1, max_length = 2000,
                      subsample=FALSE, chunk_size=NULL, out_dir = NULL, compress = TRUE,
                      force=FALSE, multithread = FALSE, quiet = TRUE, progress=FALSE) {
  .Deprecated("taxreturn::fetch_seqs", package="taxreturn",  old = as.character(sys.call(sys.parent()))[1L])


  if(!database %in% c("nuccore", "genbank", "bold")) {
    stop("database is invalid. See help page for more details")
  }

  if (!output %in% c("standard", "h", "binom", "gb", "bold", "gb-binom")) {
    stop(paste0(output, " has to be one of: 'standard', 'h','binom','bold', 'gb' or 'gb-binom', see help page for more details"))
  }

  #stop if subsample and BOLD is true
  if (is.numeric(subsample ) & database=="bold"){ stop("Subsampling is currently not supported for BOLD")}

  # Get NCBI taxonomy database if NCBI format outputs are desired
  if (database == "bold" && output %in% c("gb", "gb-binom")) {
    db <- get_ncbi_taxonomy(include_synonyms = TRUE, force=FALSE)
  }

  #Define directories
  if (is.null(out_dir)) {
    out_dir <- database
    if (!quiet) (message(paste0("No input out_dir given, saving output file to: ", out_dir)))
  }
  if (!dir.exists(out_dir)) {
    dir.create(out_dir)
  }
  out_dir <- normalizePath(out_dir)

  # Evaluate downstream
  if (is.character(downstream)) {
    if (!quiet) cat(paste0("Getting downstream taxa to the level of: ", downstream, "\n"))

    taxlist <- taxize::downstream(x, db = switch(database, bold = "bold", genbank = "ncbi", nuccore = "ncbi"),
                                  downto = downstream) %>%
      methods::as("list") %>%
      dplyr::bind_rows() %>%
      dplyr::filter(rank == stringr::str_to_lower(!!downstream)) %>%
      dplyr::mutate(downloaded = FALSE)

    if (nrow(taxlist) > 0) {
      taxon <- switch(database, bold = taxlist$name, genbank = taxlist$childtaxa_name, nuccore = taxlist$childtaxa_name)
    } else {
      (taxon <- x)
    }
    if (!quiet) cat(paste0(length(taxon), " downstream taxa found\n"))
  } else {
    taxon <- x
  }

  # Setup multithreading - only makes sense if downstream = TRUE
  setup_multithread(multithread = multithread, quiet=quiet)

  # Genbank
  if (database %in% c("genbank", "nuccore")) {
    if (subsample==FALSE) {
      message("Downloading from genbank - No subsampling")
      res <-  furrr::future_map_dfr(
        taxon, gbSearch, database = database, marker = marker,
        output = output, min_length = min_length, max_length = max_length,
        compress = compress, chunk_size=chunk_size, out_dir= out_dir,
        force=force, quiet = quiet, .progress = progress)

    } else if (is.numeric(subsample)){
      message("Downloading from genbank - With subsampling")
      res <-  furrr::future_map_dfr(
        taxon, gbSearch_subsample, database = database, marker = marker,
        out_dir = out_dir, output = output, subsample = subsample,
        min_length = min_length, max_length = max_length, chunk_size=chunk_size,
        force=force, compress = compress, quiet = quiet,  .progress = progress)
    }

  } else if (database == "bold") {
    # Split any querys above chunk_size
    if(is.null(chunk_size)){
      chunk_size <- 100000
    }
    bold_taxon <- furrr::future_map(taxon, split_bold_query, chunk_size=chunk_size, quiet=quiet, .progress = progress) %>%
      unlist()

    if(!quiet) {message("Downloading ", length(bold_taxon)," taxa from BOLD")}
    res <- furrr::future_map(
      bold_taxon, boldSearch, marker = marker, db=db,
      out_dir = out_dir, out_file = NULL, output = output,
      compress = compress, quiet = quiet,  .progress = progress, force=force)
  }

  # Explicitly close multisession workers
  future::plan(future::sequential)

  # Return results summary
  return(res %>%
           dplyr::bind_rows())
}


# Make Blast DB -----------------------------------------------------------

#' Make blast Database (DEPRECATED)
#'
#' @param file (Required) A fasta file to create a database from.
#' @param dbtype (Optional) Molecule type of database, accepts "nucl" for nucleotide or "prot" for protein.
#' @param args (Optional) Extra arguments passed to BLAST
#' @param quiet (Optional) Whether progress should be printed to console, default is FALSE
#'
#' @return
#' @export
#' @import stringr
#' @importFrom R.utils gunzip
#'
makeblastdb <- function (file, dbtype = "nucl", args = NULL, quiet = FALSE) {
  .Deprecated("taxreturn::make_blast_db", package="taxreturn",  old = as.character(sys.call(sys.parent()))[1L])

  time <- Sys.time() # get time
  .findExecutable("makeblastdb") # Check blast is installed
  if (is.null(args)){args <- ""}
  if (stringr::str_detect(file, ".gz")) {
    message("Unzipping file")
    compressed <- TRUE
    R.utils::gunzip(file, remove=FALSE)
    file <- stringr::str_replace(file, ".gz", "")
  }else (compressed <- FALSE)
  results <- system2(command = .findExecutable("makeblastdb"),
                     args = c("-in", file, "-dbtype", dbtype, args),
                     wait = TRUE,
                     stdout = TRUE)
  time <- Sys.time() - time
  if (compressed) {file.remove(file)}
  if (!quiet) (message(paste0("made BLAST DB in ", format(time, digits = 2))))

}
